<!DOCTYPE html>
<html lang=en>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="ApplyTransaction1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ApplyTransaction attempts to apply a transaction to the given state database// and uses th">
<meta property="og:type" content="article">
<meta property="og:title" content="eth_code_tx_event">
<meta property="og:url" content="https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="ApplyTransaction1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ApplyTransaction attempts to apply a transaction to the given state database// and uses th">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-07-27T06:22:44.804Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="eth_code_tx_event">
<meta name="twitter:description" content="ApplyTransaction1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ApplyTransaction attempts to apply a transaction to the given state database// and uses th">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>eth_code_tx_event</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/categories/">Categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/10/14/eth-rlp/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/10/14/eos-code/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&text=eth_code_tx_event"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&title=eth_code_tx_event"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&is_video=false&description=eth_code_tx_event"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=eth_code_tx_event&body=Check out this article: https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&title=eth_code_tx_event"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&title=eth_code_tx_event"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&title=eth_code_tx_event"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&title=eth_code_tx_event"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&name=eth_code_tx_event&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplyTransaction"><span class="toc-number">1.</span> <span class="toc-text">ApplyTransaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#handleMsg"><span class="toc-number">2.</span> <span class="toc-text">handleMsg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Start"><span class="toc-number">3.</span> <span class="toc-text">Start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fetch"><span class="toc-number">4.</span> <span class="toc-text">fetch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Downloader"><span class="toc-number">5.</span> <span class="toc-text">Downloader</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        eth_code_tx_event
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-10-14T14:47:58.000Z" itemprop="datePublished">2019-10-14</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/eth/">eth</a>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h4 id="ApplyTransaction"><a href="#ApplyTransaction" class="headerlink" title="ApplyTransaction"></a>ApplyTransaction</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// ApplyTransaction attempts to apply a transaction to the given state database</span><br><span class="line">// and uses the input parameters for its environment. It returns the receipt</span><br><span class="line">// for the transaction, gas used and an error if the transaction failed,</span><br><span class="line">// indicating the block was invalid.</span><br><span class="line">//应用交易到state database中</span><br><span class="line">func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, uint64, error) &#123;</span><br><span class="line">	//构造交易消息</span><br><span class="line">	msg, err := tx.AsMessage(types.MakeSigner(config, header.Number))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, 0, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//EVM进行交易处理，返回为处理结果、消耗gas、是否失败、err，logs是在evm处理时产生的</span><br><span class="line">	// Create a new context to be used in the EVM environment</span><br><span class="line">	context := NewEVMContext(msg, header, bc, author)</span><br><span class="line">	// Create a new environment which holds all relevant information</span><br><span class="line">	// about the transaction and calling mechanisms.</span><br><span class="line">	vmenv := vm.NewEVM(context, statedb, config, cfg)</span><br><span class="line">	// Apply the transaction to the current state (included in the env)</span><br><span class="line">	_, gas, failed, err := ApplyMessage(vmenv, msg, gp)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, 0, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//根据处理结果构建返回数据</span><br><span class="line">	// Update the state with pending changes</span><br><span class="line">	var root []byte</span><br><span class="line">	if config.IsByzantium(header.Number) &#123;</span><br><span class="line">		statedb.Finalise(true)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes()</span><br><span class="line">	&#125;</span><br><span class="line">	*usedGas += gas</span><br><span class="line"></span><br><span class="line">	// Create a new receipt for the transaction, storing the intermediate root and gas used by the tx</span><br><span class="line">	// based on the eip phase, we&apos;re passing whether the root touch-delete accounts.</span><br><span class="line">	receipt := types.NewReceipt(root, failed, *usedGas)</span><br><span class="line">	receipt.TxHash = tx.Hash()</span><br><span class="line">	receipt.GasUsed = gas</span><br><span class="line">	// if the transaction created a contract, store the creation address in the receipt.</span><br><span class="line">	if msg.To() == nil &#123;</span><br><span class="line">		receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())</span><br><span class="line">	&#125;</span><br><span class="line">	// Set the receipt logs and create a bloom for filtering</span><br><span class="line">	receipt.Logs = statedb.GetLogs(tx.Hash())</span><br><span class="line">	receipt.Bloom = types.CreateBloom(types.Receipts&#123;receipt&#125;)</span><br><span class="line"></span><br><span class="line">	return receipt, gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) &#123;</span><br><span class="line">	if evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; 0 &#123;</span><br><span class="line">		return nil, gas, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Fail if we&apos;re trying to execute above the call depth limit</span><br><span class="line">	if evm.depth &gt; int(params.CallCreateDepth) &#123;</span><br><span class="line">		return nil, gas, ErrDepth</span><br><span class="line">	&#125;</span><br><span class="line">	// Fail if we&apos;re trying to transfer more than the available balance</span><br><span class="line">	if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</span><br><span class="line">		return nil, gas, ErrInsufficientBalance</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var (</span><br><span class="line">		to       = AccountRef(addr)</span><br><span class="line">		snapshot = evm.StateDB.Snapshot()</span><br><span class="line">	)</span><br><span class="line">	if !evm.StateDB.Exist(addr) &#123;</span><br><span class="line">		precompiles := PrecompiledContractsHomestead</span><br><span class="line">		if evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</span><br><span class="line">			precompiles = PrecompiledContractsByzantium</span><br><span class="line">		&#125;</span><br><span class="line">		if precompiles[addr] == nil &amp;&amp; evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; value.Sign() == 0 &#123;</span><br><span class="line">			// Calling a non existing account, don&apos;t do anything, but ping the tracer</span><br><span class="line">			if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 &#123;</span><br><span class="line">				evm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, false, input, gas, value)</span><br><span class="line">				evm.vmConfig.Tracer.CaptureEnd(ret, 0, 0, nil)</span><br><span class="line">			&#125;</span><br><span class="line">			return nil, gas, nil</span><br><span class="line">		&#125;</span><br><span class="line">		evm.StateDB.CreateAccount(addr)</span><br><span class="line">	&#125;</span><br><span class="line">	evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)</span><br><span class="line">	// Initialise a new contract and set the code that is to be used by the EVM.</span><br><span class="line">	// The contract is a scoped environment for this execution context only.</span><br><span class="line">	contract := NewContract(caller, to, value, gas)</span><br><span class="line">	contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))</span><br><span class="line"></span><br><span class="line">	// Even if the account has no code, we need to continue because it might be a precompile</span><br><span class="line">	start := time.Now()</span><br><span class="line"></span><br><span class="line">	// Capture the tracer start/end events in debug mode</span><br><span class="line">	if evm.vmConfig.Debug &amp;&amp; evm.depth == 0 &#123;</span><br><span class="line">		evm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, false, input, gas, value)</span><br><span class="line"></span><br><span class="line">		defer func() &#123; // Lazy evaluation of the parameters</span><br><span class="line">			evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	ret, err = run(evm, contract, input, false)</span><br><span class="line"></span><br><span class="line">	// When an error was returned by the EVM or when setting the creation code</span><br><span class="line">	// above we revert to the snapshot and consume any gas remaining. Additionally</span><br><span class="line">	// when we&apos;re in homestead this also counts for code storage gas errors.</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">		if err != errExecutionReverted &#123;</span><br><span class="line">			contract.UseGas(contract.Gas)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret, contract.Gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="handleMsg"><a href="#handleMsg" class="headerlink" title="handleMsg"></a>handleMsg</h4><p>处理接收到的消息码</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StatusMsg</span><br></pre></td></tr></table></figure>

<p>收到这个消息说明握手失败</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetBlockHeadersMsg</span><br></pre></td></tr></table></figure>

<p>查询区块头请求，回复区块头信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockHeadersMsg</span><br></pre></td></tr></table></figure>

<p>区块头信息的回复</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetBlockBodiesMsg</span><br></pre></td></tr></table></figure>

<p>查询区块请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockBodiesMsg</span><br></pre></td></tr></table></figure>

<p>区块请求查询的回复，</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetNodeDataMsg</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NodeDataMsg</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetReceiptsMsg</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReceiptsMsg</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NewBlockHashesMsg</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NewBlockMsg</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TxMsg</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h4><p>这四个goroutine 基本上就在不停的做广播区块、广播交易，同步到区块、同步到交易，再广播区块、广播交易。</p>
<ul>
<li><p>txBroadcastLoop</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func (self *ProtocolManager) txBroadcastLoop() &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case event := &lt;-self.txCh:</span><br><span class="line">            self.BroadcastTx(event.Tx.Hash(), event.Tx)</span><br><span class="line"></span><br><span class="line">        // Err() channel will be closed when unsubscribing.</span><br><span class="line">        case &lt;-self.txSub.Err():</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>core/tx_pool.go 产生新的交易的时候会send self.txCh，这时候会激活<br>self.BroadcastTx(event.Tx.Hash(), event.Tx)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (pm *ProtocolManager) BroadcastTx(hash common.Hash, tx *types.Transaction) &#123;</span><br><span class="line">    // Broadcast transaction to a batch of peers not knowing about it</span><br><span class="line">    peers := pm.peers.PeersWithoutTx(hash)</span><br><span class="line">    //FIXME include this again: peers = peers[:int(math.Sqrt(float64(len(peers))))]</span><br><span class="line">    for _, peer := range peers &#123;</span><br><span class="line">        peer.SendTransactions(types.Transactions&#123;tx&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Trace(&quot;Broadcast transaction&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(peers))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向缓存的没有这个交易hash的网络节点广播此次交易。</p>
</li>
<li><p>minedBroadcastLoop</p>
<p>收到miner.go 里面NewMinedBlockEvent 挖到新区块的事件通知，激活self.BroadcastBlock(ev.Block, true)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Mined broadcast loop</span><br><span class="line">func (self *ProtocolManager) minedBroadcastLoop() &#123;</span><br><span class="line">    // automatically stops if unsubscribe</span><br><span class="line">    for obj := range self.minedBlockSub.Chan() &#123;</span><br><span class="line">        switch ev := obj.Data.(type) &#123;</span><br><span class="line">        case core.NewMinedBlockEvent:</span><br><span class="line">            self.BroadcastBlock(ev.Block, true)  // First propagate block to peers</span><br><span class="line">            self.BroadcastBlock(ev.Block, false) // Only then announce to the rest</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func (pm *ProtocolManager) BroadcastBlock(block *types.Block, propagate bool) &#123;</span><br><span class="line">    hash := block.Hash()</span><br><span class="line">    peers := pm.peers.PeersWithoutBlock(hash)</span><br><span class="line"></span><br><span class="line">    // If propagation is requested, send to a subset of the peer</span><br><span class="line">    if propagate &#123;</span><br><span class="line">        // Calculate the TD of the block (it&apos;s not imported yet, so block.Td is not valid)</span><br><span class="line">        var td *big.Int</span><br><span class="line">        if parent := pm.blockchain.GetBlock(block.ParentHash(), block.NumberU64()-1); parent != nil &#123;</span><br><span class="line">            td = new(big.Int).Add(block.Difficulty(), pm.blockchain.GetTd(block.ParentHash(), block.NumberU64()-1))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.Error(&quot;Propagating dangling block&quot;, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        // Send the block to a subset of our peers</span><br><span class="line">        transfer := peers[:int(math.Sqrt(float64(len(peers))))]</span><br><span class="line">        for _, peer := range transfer &#123;</span><br><span class="line">            peer.SendNewBlock(block, td)</span><br><span class="line">        &#125;</span><br><span class="line">        log.Trace(&quot;Propagated block&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(transfer), &quot;duration&quot;, common.PrettyDuration(time.Since(block.ReceivedAt)))</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // Otherwise if the block is indeed in out own chain, announce it</span><br><span class="line">    if pm.blockchain.HasBlock(hash, block.NumberU64()) &#123;</span><br><span class="line">        for _, peer := range peers &#123;</span><br><span class="line">            peer.SendNewBlockHashes([]common.Hash&#123;hash&#125;, []uint64&#123;block.NumberU64()&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        log.Trace(&quot;Announced block&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(peers), &quot;duration&quot;, common.PrettyDuration(time.Since(block.ReceivedAt)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果propagate为true 向网络节点广播整个挖到的block，为false 只广播挖到的区块的hash值和number值。广播的区块还包括这个区块打包的所有交易。</p>
</li>
<li><p>syncer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func (pm *ProtocolManager) syncer() &#123;</span><br><span class="line">    // Start and ensure cleanup of sync mechanisms</span><br><span class="line">    pm.fetcher.Start()</span><br><span class="line">    defer pm.fetcher.Stop()</span><br><span class="line">    defer pm.downloader.Terminate()</span><br><span class="line"></span><br><span class="line">    // Wait for different events to fire synchronisation operations</span><br><span class="line">    forceSync := time.NewTicker(forceSyncCycle)</span><br><span class="line">    defer forceSync.Stop()</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-pm.newPeerCh:</span><br><span class="line">            // Make sure we have peers to select from, then sync</span><br><span class="line">            if pm.peers.Len() &lt; minDesiredPeerCount &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            go pm.synchronise(pm.peers.BestPeer())</span><br><span class="line"></span><br><span class="line">        case &lt;-forceSync.C:</span><br><span class="line">            // Force a sync even if not enough peers are present</span><br><span class="line">            go pm.synchronise(pm.peers.BestPeer())</span><br><span class="line"></span><br><span class="line">        case &lt;-pm.noMorePeers:</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pm.fetcher.Start()启动 fetcher，辅助同步区块数据</p>
<p>当P2P server执行 ProtocolManager 的p2p.Protocol 的Run指针的时候会send pm.newPeerCh，这时候选择最优的网络节点（TD 总难度最大的）启动pm.synchronise(pm.peers.BestPeer()) goroutine。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// synchronise tries to sync up our local block chain with a remote peer.</span><br><span class="line">func (pm *ProtocolManager) synchronise(peer *peer) &#123;</span><br><span class="line">    // Short circuit if no peers are available</span><br><span class="line">    if peer == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // Make sure the peer&apos;s TD is higher than our own</span><br><span class="line">    currentBlock := pm.blockchain.CurrentBlock()</span><br><span class="line">    td := pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())</span><br><span class="line"></span><br><span class="line">    pHead, pTd := peer.Head()</span><br><span class="line">    if pTd.Cmp(td) &lt;= 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // Otherwise try to sync with the downloader</span><br><span class="line">    mode := downloader.FullSync</span><br><span class="line">    if atomic.LoadUint32(&amp;pm.fastSync) == 1 &#123;</span><br><span class="line">        // Fast sync was explicitly requested, and explicitly granted</span><br><span class="line">        mode = downloader.FastSync</span><br><span class="line">    &#125; else if currentBlock.NumberU64() == 0 &amp;&amp; pm.blockchain.CurrentFastBlock().NumberU64() &gt; 0 &#123;</span><br><span class="line">        // The database seems empty as the current block is the genesis. Yet the fast</span><br><span class="line">        // block is ahead, so fast sync was enabled for this node at a certain point.</span><br><span class="line">        // The only scenario where this can happen is if the user manually (or via a</span><br><span class="line">        // bad block) rolled back a fast sync node below the sync point. In this case</span><br><span class="line">        // however it&apos;s safe to reenable fast sync.</span><br><span class="line">        atomic.StoreUint32(&amp;pm.fastSync, 1)</span><br><span class="line">        mode = downloader.FastSync</span><br><span class="line">    &#125;</span><br><span class="line">    // Run the sync cycle, and disable fast sync if we&apos;ve went past the pivot block</span><br><span class="line">    if err := pm.downloader.Synchronise(peer.id, pHead, pTd, mode); err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if atomic.LoadUint32(&amp;pm.fastSync) == 1 &#123;</span><br><span class="line">        log.Info(&quot;Fast sync complete, auto disabling&quot;)</span><br><span class="line">        atomic.StoreUint32(&amp;pm.fastSync, 0)</span><br><span class="line">    &#125;</span><br><span class="line">    atomic.StoreUint32(&amp;pm.acceptTxs, 1) // Mark initial sync done</span><br><span class="line">    if head := pm.blockchain.CurrentBlock(); head.NumberU64() &gt; 0 &#123;</span><br><span class="line">        // We&apos;ve completed a sync cycle, notify all peers of new state. This path is</span><br><span class="line">        // essential in star-topology networks where a gateway node needs to notify</span><br><span class="line">        // all its out-of-date peers of the availability of a new block. This failure</span><br><span class="line">        // scenario will most often crop up in private and hackathon networks with</span><br><span class="line">        // degenerate connectivity, but it should be healthy for the mainnet too to</span><br><span class="line">        // more reliably update peers or the local TD state.</span><br><span class="line">        go pm.BroadcastBlock(head, false)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果最优的网络节点的TD值大于本地最新区块的TD值，调用pm.downloader.Synchronise(peer.id, pHead, pTd, mode)进行同步。同步完成后再屌用go pm.BroadcastBlock(head, false)，把自己最新的区块状态广播出去。</p>
</li>
<li><p>txsyncLoop</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">func (pm *ProtocolManager) txsyncLoop() &#123;</span><br><span class="line">    var (</span><br><span class="line">        pending = make(map[discover.NodeID]*txsync)</span><br><span class="line">        sending = false               // whether a send is active</span><br><span class="line">        pack    = new(txsync)         // the pack that is being sent</span><br><span class="line">        done    = make(chan error, 1) // result of the send</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    // send starts a sending a pack of transactions from the sync.</span><br><span class="line">    send := func(s *txsync) &#123;</span><br><span class="line">        // Fill pack with transactions up to the target size.</span><br><span class="line">        size := common.StorageSize(0)</span><br><span class="line">        pack.p = s.p</span><br><span class="line">        pack.txs = pack.txs[:0]</span><br><span class="line">        for i := 0; i &lt; len(s.txs) &amp;&amp; size &lt; txsyncPackSize; i++ &#123;</span><br><span class="line">            pack.txs = append(pack.txs, s.txs[i])</span><br><span class="line">            size += s.txs[i].Size()</span><br><span class="line">        &#125;</span><br><span class="line">        // Remove the transactions that will be sent.</span><br><span class="line">        s.txs = s.txs[:copy(s.txs, s.txs[len(pack.txs):])]</span><br><span class="line">        if len(s.txs) == 0 &#123;</span><br><span class="line">            delete(pending, s.p.ID())</span><br><span class="line">        &#125;</span><br><span class="line">        // Send the pack in the background.</span><br><span class="line">        s.p.Log().Trace(&quot;Sending batch of transactions&quot;, &quot;count&quot;, len(pack.txs), &quot;bytes&quot;, size)</span><br><span class="line">        sending = true</span><br><span class="line">        go func() &#123; done &lt;- pack.p.SendTransactions(pack.txs) &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // pick chooses the next pending sync.</span><br><span class="line">    pick := func() *txsync &#123;</span><br><span class="line">        if len(pending) == 0 &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        n := rand.Intn(len(pending)) + 1</span><br><span class="line">        for _, s := range pending &#123;</span><br><span class="line">            if n--; n == 0 &#123;</span><br><span class="line">                return s</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case s := &lt;-pm.txsyncCh:</span><br><span class="line">            pending[s.p.ID()] = s</span><br><span class="line">            if !sending &#123;</span><br><span class="line">                send(s)</span><br><span class="line">            &#125;</span><br><span class="line">        case err := &lt;-done:</span><br><span class="line">            sending = false</span><br><span class="line">            // Stop tracking peers that cause send failures.</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                pack.p.Log().Debug(&quot;Transaction send failed&quot;, &quot;err&quot;, err)</span><br><span class="line">                delete(pending, pack.p.ID())</span><br><span class="line">            &#125;</span><br><span class="line">            // Schedule the next send.</span><br><span class="line">            if s := pick(); s != nil &#123;</span><br><span class="line">                send(s)</span><br><span class="line">            &#125;</span><br><span class="line">        case &lt;-pm.quitSync:</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当从网络节点同步过来最新的交易数据后，本地也会把新同步下来的交易数据广播给网络中的其他节点。</p>
</li>
</ul>
<h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><p>fetcher是用来辅助同步区块数据的，记录各个区块头和区块体的同步状态，但它并不做真正下载区块数据的事情，下载的事情交由downloader来做。那fetcher具体是怎么工作的呢？<br>我们先看看pm.handleMsg 在收到 NewBlockHashesMsg广播通知的处理代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">case msg.Code == NewBlockHashesMsg:</span><br><span class="line">        var announces newBlockHashesData</span><br><span class="line">        if err := msg.Decode(&amp;announces); err != nil &#123;</span><br><span class="line">            return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err)</span><br><span class="line">        &#125;</span><br><span class="line">        // Mark the hashes as present at the remote node</span><br><span class="line">        for _, block := range announces &#123;</span><br><span class="line">            p.MarkBlock(block.Hash)</span><br><span class="line">        &#125;</span><br><span class="line">        // Schedule all the unknown hashes for retrieval</span><br><span class="line">        unknown := make(newBlockHashesData, 0, len(announces))</span><br><span class="line">        for _, block := range announces &#123;</span><br><span class="line">            if !pm.blockchain.HasBlock(block.Hash, block.Number) &#123;</span><br><span class="line">                unknown = append(unknown, block)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for _, block := range unknown &#123;</span><br><span class="line">            pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从广播通知里会获取到一个newBlockHashesData的列表。newBlockHashesData只包括block的hash值和block的number值。<br>然后每个newBlockHashesData调用pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies)方法，除了传入block的hash值和block的number值，还需要传入当前的时间戳，peer.go的两个函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (f *Fetcher) Notify(peer string, hash common.Hash, number uint64, time time.Time,</span><br><span class="line">    headerFetcher headerRequesterFn, bodyFetcher bodyRequesterFn) error &#123;</span><br><span class="line">    block := &amp;announce&#123;</span><br><span class="line">        hash:        hash,</span><br><span class="line">        number:      number,</span><br><span class="line">        time:        time,</span><br><span class="line">        origin:      peer,</span><br><span class="line">        fetchHeader: headerFetcher,</span><br><span class="line">        fetchBodies: bodyFetcher,</span><br><span class="line">    &#125;</span><br><span class="line">    select &#123;</span><br><span class="line">    case f.notify &lt;- block:</span><br><span class="line">        return nil</span><br><span class="line">    case &lt;-f.quit:</span><br><span class="line">        return errTerminated</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notify()方法把传进来的参数拼成一个announce对象，然后send给f.notify。fetcher的loop()主回路里f.notify receive 到这个notification, 进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">case notification := &lt;-f.notify:</span><br><span class="line">            // A block was announced, make sure the peer isn&apos;t DOSing us</span><br><span class="line">            propAnnounceInMeter.Mark(1)</span><br><span class="line"></span><br><span class="line">            count := f.announces[notification.origin] + 1</span><br><span class="line">            if count &gt; hashLimit &#123;</span><br><span class="line">                log.Debug(&quot;Peer exceeded outstanding announces&quot;, &quot;peer&quot;, notification.origin, &quot;limit&quot;, hashLimit)</span><br><span class="line">                propAnnounceDOSMeter.Mark(1)</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            // If we have a valid block number, check that it&apos;s potentially useful</span><br><span class="line">            if notification.number &gt; 0 &#123;</span><br><span class="line">                if dist := int64(notification.number) - int64(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist &#123;</span><br><span class="line">                    log.Debug(&quot;Peer discarded announcement&quot;, &quot;peer&quot;, notification.origin, &quot;number&quot;, notification.number, &quot;hash&quot;, notification.hash, &quot;distance&quot;, dist)</span><br><span class="line">                    propAnnounceDropMeter.Mark(1)</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // All is well, schedule the announce if block&apos;s not yet downloading</span><br><span class="line">            if _, ok := f.fetching[notification.hash]; ok &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            if _, ok := f.completing[notification.hash]; ok &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            f.announces[notification.origin] = count</span><br><span class="line">            f.announced[notification.hash] = append(f.announced[notification.hash], notification)</span><br><span class="line">            if f.announceChangeHook != nil &amp;&amp; len(f.announced[notification.hash]) == 1 &#123;</span><br><span class="line">                f.announceChangeHook(notification.hash, true)</span><br><span class="line">            &#125;</span><br><span class="line">            if len(f.announced) == 1 &#123;</span><br><span class="line">                f.rescheduleFetch(fetchTimer)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>1，将收到的不满足条件的通知都丢弃掉，如果在f.fetching 状态列表里和f.completing 状态列表里，也直接返回。接着更新notification.origin 这个节点的announces 数量，添加到f.announced 等待fetch的表里。<br>2，如果len(f.announced[notification.hash]) == 1 说明f.announced只有这一个通知，则调用f.announceChangeHook。<br>3，如果len(f.announced) == 1 也说明只有一个通知，则启动fetchTimer的调度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">case &lt;-fetchTimer.C:</span><br><span class="line">            // At least one block&apos;s timer ran out, check for needing retrieval</span><br><span class="line">            request := make(map[string][]common.Hash)</span><br><span class="line"></span><br><span class="line">            for hash, announces := range f.announced &#123;</span><br><span class="line">                if time.Since(announces[0].time) &gt; arriveTimeout-gatherSlack &#123;</span><br><span class="line">                    // Pick a random peer to retrieve from, reset all others</span><br><span class="line">                    announce := announces[rand.Intn(len(announces))]</span><br><span class="line">                    f.forgetHash(hash)</span><br><span class="line"></span><br><span class="line">                    // If the block still didn&apos;t arrive, queue for fetching</span><br><span class="line">                    if f.getBlock(hash) == nil &#123;</span><br><span class="line">                        request[announce.origin] = append(request[announce.origin], hash)</span><br><span class="line">                        f.fetching[hash] = announce</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // Send out all block header requests</span><br><span class="line">            for peer, hashes := range request &#123;</span><br><span class="line">                log.Trace(&quot;Fetching scheduled headers&quot;, &quot;peer&quot;, peer, &quot;list&quot;, hashes)</span><br><span class="line"></span><br><span class="line">                // Create a closure of the fetch and schedule in on a new thread</span><br><span class="line">                fetchHeader, hashes := f.fetching[hashes[0]].fetchHeader, hashes</span><br><span class="line">                go func() &#123;</span><br><span class="line">                    if f.fetchingHook != nil &#123;</span><br><span class="line">                        f.fetchingHook(hashes)</span><br><span class="line">                    &#125;</span><br><span class="line">                    for _, hash := range hashes &#123;</span><br><span class="line">                        headerFetchMeter.Mark(1)</span><br><span class="line">                        fetchHeader(hash) // Suboptimal, but protocol doesn&apos;t allow batch header retrievals</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;()</span><br><span class="line">            &#125;</span><br><span class="line">            // Schedule the next fetch if blocks are still pending</span><br><span class="line">            f.rescheduleFetch(fetchTimer)</span><br></pre></td></tr></table></figure>

<p>1，首先遍历f.announced，如果超过了arriveTimeout-gatherSlack这个时间，把这个hash对应在fetcher里面的状态都清了。<br>这里随机拿这个announces里面任意一个announce，为啥随机取一个呢？因为都是同一个block的hash，这个hash下的哪一个announce都是一样的。<br>如果发现超时了还没有没有获取到这个hash的block，则把这个announce加到request列表中，同时重新把announce放到f.fetching状态列表。<br>2，然后遍历request列表，request列表里面的每个网络节点过来的所有的block的hash，都会调用fetchHeader(hash)方法来获取header数据。<br>这个fetchHeader(hash)方法是pm.fetcher.Notify传进来的，peer.go<br>里面的一个全局方法。<br>3， 这时候NewBlockHashesMsg 的fetcher处理就结束了，最后再启动fetchTimer的调度。</p>
<p>三，Fetcher分析， 之FilterHeaders()<br>fetchHeader(hash)方法，调用了peer.go 里面的全局方法RequestOneHeader(hash common.Hash)  Send给网络节点一个GetBlockHeadersMsg 消息。<br>然后pm.handleMsg 收到 BlockHashesMsg广播通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">case msg.Code == BlockHeadersMsg:</span><br><span class="line">        // A batch of headers arrived to one of our previous requests</span><br><span class="line">        var headers []*types.Header</span><br><span class="line">        if err := msg.Decode(&amp;headers); err != nil &#123;</span><br><span class="line">            return errResp(ErrDecode, &quot;msg %v: %v&quot;, msg, err)</span><br><span class="line">        &#125;</span><br><span class="line">        // If no headers were received, but we&apos;re expending a DAO fork check, maybe it&apos;s that</span><br><span class="line">        if len(headers) == 0 &amp;&amp; p.forkDrop != nil &#123;</span><br><span class="line">            // Possibly an empty reply to the fork header checks, sanity check TDs</span><br><span class="line">            verifyDAO := true</span><br><span class="line"></span><br><span class="line">            // If we already have a DAO header, we can check the peer&apos;s TD against it. If</span><br><span class="line">            // the peer&apos;s ahead of this, it too must have a reply to the DAO check</span><br><span class="line">            if daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != nil &#123;</span><br><span class="line">                if _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= 0 &#123;</span><br><span class="line">                    verifyDAO = false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // If we&apos;re seemingly on the same chain, disable the drop timer</span><br><span class="line">            if verifyDAO &#123;</span><br><span class="line">                p.Log().Debug(&quot;Seems to be on the same side of the DAO fork&quot;)</span><br><span class="line">                p.forkDrop.Stop()</span><br><span class="line">                p.forkDrop = nil</span><br><span class="line">                return nil</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Filter out any explicitly requested headers, deliver the rest to the downloader</span><br><span class="line">        filter := len(headers) == 1</span><br><span class="line">        if filter &#123;</span><br><span class="line">            // If it&apos;s a potential DAO fork check, validate against the rules</span><br><span class="line">            if p.forkDrop != nil &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[0].Number) == 0 &#123;</span><br><span class="line">                // Disable the fork drop timer</span><br><span class="line">                p.forkDrop.Stop()</span><br><span class="line">                p.forkDrop = nil</span><br><span class="line"></span><br><span class="line">                // Validate the header and either drop the peer or continue</span><br><span class="line">                if err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[0]); err != nil &#123;</span><br><span class="line">                    p.Log().Debug(&quot;Verified to be on the other side of the DAO fork, dropping&quot;)</span><br><span class="line">                    return err</span><br><span class="line">                &#125;</span><br><span class="line">                p.Log().Debug(&quot;Verified to be on the same side of the DAO fork&quot;)</span><br><span class="line">                return nil</span><br><span class="line">            &#125;</span><br><span class="line">            // Irrelevant of the fork checks, send the header to the fetcher just in case</span><br><span class="line">            headers = pm.fetcher.FilterHeaders(p.id, headers, time.Now())</span><br><span class="line">        &#125;</span><br><span class="line">        if len(headers) &gt; 0 || !filter &#123;</span><br><span class="line">            err := pm.downloader.DeliverHeaders(p.id, headers)</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Debug(&quot;Failed to deliver headers&quot;, &quot;err&quot;, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果不是硬分叉的daoHeader，同时len(headers) == 1，则执行pm.fetcher.FilterHeaders(p.id, headers, time.Now())方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func (f *Fetcher) FilterHeaders(peer string, headers []*types.Header, time time.Time) []*types.Header &#123;</span><br><span class="line">    log.Trace(&quot;Filtering headers&quot;, &quot;peer&quot;, peer, &quot;headers&quot;, len(headers))</span><br><span class="line"></span><br><span class="line">    // Send the filter channel to the fetcher</span><br><span class="line">    filter := make(chan *headerFilterTask)</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case f.headerFilter &lt;- filter:</span><br><span class="line">    case &lt;-f.quit:</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    // Request the filtering of the header list</span><br><span class="line">    select &#123;</span><br><span class="line">    case filter &lt;- &amp;headerFilterTask&#123;peer: peer, headers: headers, time: time&#125;:</span><br><span class="line">    case &lt;-f.quit:</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    // Retrieve the headers remaining after filtering</span><br><span class="line">    select &#123;</span><br><span class="line">    case task := &lt;-filter:</span><br><span class="line">        return task.headers</span><br><span class="line">    case &lt;-f.quit:</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>send 一个filter 到f.headerFilter，fetcher的loop()主回路里f.headerFilter receive 到这个filter，进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">case filter := &lt;-f.headerFilter:</span><br><span class="line">            // Headers arrived from a remote peer. Extract those that were explicitly</span><br><span class="line">            // requested by the fetcher, and return everything else so it&apos;s delivered</span><br><span class="line">            // to other parts of the system.</span><br><span class="line">            var task *headerFilterTask</span><br><span class="line">            select &#123;</span><br><span class="line">            case task = &lt;-filter:</span><br><span class="line">            case &lt;-f.quit:</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            headerFilterInMeter.Mark(int64(len(task.headers)))</span><br><span class="line"></span><br><span class="line">            // Split the batch of headers into unknown ones (to return to the caller),</span><br><span class="line">            // known incomplete ones (requiring body retrievals) and completed blocks.</span><br><span class="line">            unknown, incomplete, complete := []*types.Header&#123;&#125;, []*announce&#123;&#125;, []*types.Block&#123;&#125;</span><br><span class="line">            for _, header := range task.headers &#123;</span><br><span class="line">                hash := header.Hash()</span><br><span class="line"></span><br><span class="line">                // Filter fetcher-requested headers from other synchronisation algorithms</span><br><span class="line">                if announce := f.fetching[hash]; announce != nil &amp;&amp; announce.origin == task.peer &amp;&amp; f.fetched[hash] == nil &amp;&amp; f.completing[hash] == nil &amp;&amp; f.queued[hash] == nil &#123;</span><br><span class="line">                    // If the delivered header does not match the promised number, drop the announcer</span><br><span class="line">                    if header.Number.Uint64() != announce.number &#123;</span><br><span class="line">                        log.Trace(&quot;Invalid block number fetched&quot;, &quot;peer&quot;, announce.origin, &quot;hash&quot;, header.Hash(), &quot;announced&quot;, announce.number, &quot;provided&quot;, header.Number)</span><br><span class="line">                        f.dropPeer(announce.origin)</span><br><span class="line">                        f.forgetHash(hash)</span><br><span class="line">                        continue</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Only keep if not imported by other means</span><br><span class="line">                    if f.getBlock(hash) == nil &#123;</span><br><span class="line">                        announce.header = header</span><br><span class="line">                        announce.time = task.time</span><br><span class="line"></span><br><span class="line">                        // If the block is empty (header only), short circuit into the final import queue</span><br><span class="line">                        if header.TxHash == types.DeriveSha(types.Transactions&#123;&#125;) &amp;&amp; header.UncleHash == types.CalcUncleHash([]*types.Header&#123;&#125;) &#123;</span><br><span class="line">                            log.Trace(&quot;Block empty, skipping body retrieval&quot;, &quot;peer&quot;, announce.origin, &quot;number&quot;, header.Number, &quot;hash&quot;, header.Hash())</span><br><span class="line"></span><br><span class="line">                            block := types.NewBlockWithHeader(header)</span><br><span class="line">                            block.ReceivedAt = task.time</span><br><span class="line"></span><br><span class="line">                            complete = append(complete, block)</span><br><span class="line">                            f.completing[hash] = announce</span><br><span class="line">                            continue</span><br><span class="line">                        &#125;</span><br><span class="line">                        // Otherwise add to the list of blocks needing completion</span><br><span class="line">                        incomplete = append(incomplete, announce)</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        log.Trace(&quot;Block already imported, discarding header&quot;, &quot;peer&quot;, announce.origin, &quot;number&quot;, header.Number, &quot;hash&quot;, header.Hash())</span><br><span class="line">                        f.forgetHash(hash)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Fetcher doesn&apos;t know about it, add to the return list</span><br><span class="line">                    unknown = append(unknown, header)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            headerFilterOutMeter.Mark(int64(len(unknown)))</span><br><span class="line">            select &#123;</span><br><span class="line">            case filter &lt;- &amp;headerFilterTask&#123;headers: unknown, time: task.time&#125;:</span><br><span class="line">            case &lt;-f.quit:</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            // Schedule the retrieved headers for body completion</span><br><span class="line">            for _, announce := range incomplete &#123;</span><br><span class="line">                hash := announce.header.Hash()</span><br><span class="line">                if _, ok := f.completing[hash]; ok &#123;</span><br><span class="line">                    continue</span><br><span class="line">                &#125;</span><br><span class="line">                f.fetched[hash] = append(f.fetched[hash], announce)</span><br><span class="line">                if len(f.fetched) == 1 &#123;</span><br><span class="line">                    f.rescheduleComplete(completeTimer)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // Schedule the header-only blocks for import</span><br><span class="line">            for _, block := range complete &#123;</span><br><span class="line">                if announce := f.completing[block.Hash()]; announce != nil &#123;</span><br><span class="line">                    f.enqueue(announce.origin, block)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>1，遍历headerFilter里面的各个header，如果在 f.fetching状态列表，且不在f.fetched状态列表和 f.completing状态列表，就继续进行过滤，否则塞进unknown队列 发送给filter，FilterHeaders里面task 接收到filter，并作为FilterHeaders的返回值返回。<br>2，如果发现这个header的number和从f.fetching状态列表取到的announce的number不一样，说明有可能收到一个伪造的区块通知，此时就要把这个可能的伪造节点和可能的伪造的hash抛弃，另可错杀，不能放过。<br>3，如果本节点已经有这个hash的block，则放弃这个hash。如果这个block里面没有任何交易也没有任何叔区块，则把这个hash放入complete列表同时加入f.completing状态列表，否则放入incomplete列表。<br>4，在incomplete列表里面，且不在f.completing状态列表里，则加入f.fetched状态列表，启动completeTimer的调度。<br>5，在complete列表里面，同时也在f.completing状态列表，则调用f.enqueue(announce.origin, block)方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">case &lt;-completeTimer.C:</span><br><span class="line">            // At least one header&apos;s timer ran out, retrieve everything</span><br><span class="line">            request := make(map[string][]common.Hash)</span><br><span class="line"></span><br><span class="line">            for hash, announces := range f.fetched &#123;</span><br><span class="line">                // Pick a random peer to retrieve from, reset all others</span><br><span class="line">                announce := announces[rand.Intn(len(announces))]</span><br><span class="line">                f.forgetHash(hash)</span><br><span class="line"></span><br><span class="line">                // If the block still didn&apos;t arrive, queue for completion</span><br><span class="line">                if f.getBlock(hash) == nil &#123;</span><br><span class="line">                    request[announce.origin] = append(request[announce.origin], hash)</span><br><span class="line">                    f.completing[hash] = announce</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // Send out all block body requests</span><br><span class="line">            for peer, hashes := range request &#123;</span><br><span class="line">                log.Trace(&quot;Fetching scheduled bodies&quot;, &quot;peer&quot;, peer, &quot;list&quot;, hashes)</span><br><span class="line"></span><br><span class="line">                // Create a closure of the fetch and schedule in on a new thread</span><br><span class="line">                if f.completingHook != nil &#123;</span><br><span class="line">                    f.completingHook(hashes)</span><br><span class="line">                &#125;</span><br><span class="line">                bodyFetchMeter.Mark(int64(len(hashes)))</span><br><span class="line">                go f.completing[hashes[0]].fetchBodies(hashes)</span><br><span class="line">            &#125;</span><br><span class="line">            // Schedule the next fetch if blocks are still pending</span><br><span class="line">            f.rescheduleComplete(completeTimer)</span><br></pre></td></tr></table></figure>

<p>1，首先遍历f.fetched，hash对应在fetcher里面的状态都清了。<br>如果发现超时了还没有没有获取到这个hash的block，则把这个announce加到request列表中，同时重新把announce放到f.completing状态列表。<br>2，然后遍历request列表，request列表里面的每个网络节点过来的所有的block的hash，都会调用fetchBodies(hashes)方法来获取区块body数据。这个fetchBodies(hashes)方法是peer.go里面的一个全局方法。<br>3， 这时候BlockHashesMsg 的fetcher处理就结束了，最后再启动completeTimer循环调度。</p>
<p>四，Fetcher分析， 之FilterBodies() ，Enqueue(），<br>1，fetchBodies(hash)方法，调用了peer.go 里面的全局方法RequestBodies(hashes []common.Hash) Send给网络节点一个GetBlockBodiesMsg 消息。<br>2，然后pm.handleMsg 会收到 BlockBodiesMsg广播通知。<br>3，执行 pm.fetcher.FilterBodies(p.id, trasactions, uncles, time.Now())。<br>接下来就和FilterHeaders()流程类似，一顿啪啪啪验证，一顿啪啪啪改变状态，一顿啪啪啪通道跳转<br>4，庆幸的是，走完FilterBodies()就完事了，不用在走timer调度，也不用再发网络请求了。<br>5，在FilterHeaders()和FilterBodies()最后都走到了f.enqueue(announce.origin, block)方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func (f *Fetcher) enqueue(peer string, block *types.Block) &#123;</span><br><span class="line">    hash := block.Hash()</span><br><span class="line"></span><br><span class="line">    // Ensure the peer isn&apos;t DOSing us</span><br><span class="line">    count := f.queues[peer] + 1</span><br><span class="line">    if count &gt; blockLimit &#123;</span><br><span class="line">        log.Debug(&quot;Discarded propagated block, exceeded allowance&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;limit&quot;, blockLimit)</span><br><span class="line">        propBroadcastDOSMeter.Mark(1)</span><br><span class="line">        f.forgetHash(hash)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // Discard any past or too distant blocks</span><br><span class="line">    if dist := int64(block.NumberU64()) - int64(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist &#123;</span><br><span class="line">        log.Debug(&quot;Discarded propagated block, too far away&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;distance&quot;, dist)</span><br><span class="line">        propBroadcastDropMeter.Mark(1)</span><br><span class="line">        f.forgetHash(hash)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // Schedule the block for future importing</span><br><span class="line">    if _, ok := f.queued[hash]; !ok &#123;</span><br><span class="line">        op := &amp;inject&#123;</span><br><span class="line">            origin: peer,</span><br><span class="line">            block:  block,</span><br><span class="line">        &#125;</span><br><span class="line">        f.queues[peer] = count</span><br><span class="line">        f.queued[hash] = op</span><br><span class="line">        f.queue.Push(op, -float32(block.NumberU64()))</span><br><span class="line">        if f.queueChangeHook != nil &#123;</span><br><span class="line">            f.queueChangeHook(op.block.Hash(), true)</span><br><span class="line">        &#125;</span><br><span class="line">        log.Debug(&quot;Queued propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;queued&quot;, f.queue.Size())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤掉太远的区块。并把hash加入到f.queue列表中。<br>在loop主回路里面遍历f.queue列表，并把列表中的block insert到本地的block chain中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func (f *Fetcher) insert(peer string, block *types.Block) &#123;</span><br><span class="line">    hash := block.Hash()</span><br><span class="line"></span><br><span class="line">    // Run the import on a new thread</span><br><span class="line">    log.Debug(&quot;Importing propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer func() &#123; f.done &lt;- hash &#125;()</span><br><span class="line"></span><br><span class="line">        // If the parent&apos;s unknown, abort insertion</span><br><span class="line">        parent := f.getBlock(block.ParentHash())</span><br><span class="line">        if parent == nil &#123;</span><br><span class="line">            log.Debug(&quot;Unknown parent of propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;parent&quot;, block.ParentHash())</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        // Quickly validate the header and propagate the block if it passes</span><br><span class="line">        switch err := f.verifyHeader(block.Header()); err &#123;</span><br><span class="line">        case nil:</span><br><span class="line">            // All ok, quickly propagate to our peers</span><br><span class="line">            propBroadcastOutTimer.UpdateSince(block.ReceivedAt)</span><br><span class="line">            go f.broadcastBlock(block, true)</span><br><span class="line"></span><br><span class="line">        case consensus.ErrFutureBlock:</span><br><span class="line">            // Weird future block, don&apos;t fail, but neither propagate</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            // Something went very wrong, drop the peer</span><br><span class="line">            log.Debug(&quot;Propagated block verification failed&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;err&quot;, err)</span><br><span class="line">            f.dropPeer(peer)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        // Run the actual import and log any issues</span><br><span class="line">        if _, err := f.insertChain(types.Blocks&#123;block&#125;); err != nil &#123;</span><br><span class="line">            log.Debug(&quot;Propagated block import failed&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;err&quot;, err)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        // If import succeeded, broadcast the block</span><br><span class="line">        propAnnounceOutTimer.UpdateSince(block.ReceivedAt)</span><br><span class="line">        go f.broadcastBlock(block, false)</span><br><span class="line"></span><br><span class="line">        // Invoke the testing hook if needed</span><br><span class="line">        if f.importedHook != nil &#123;</span><br><span class="line">            f.importedHook(block)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用共识引擎的方法f.verifyHeader(block.Header())，验证blockHeader的有效性。<br>如果没问题就广播出去，告诉全世界我的区块链更新了一个新区块。<br>然后调用f.insertChain(types.Blocks{block}) 插入本地区块链。<br>插入成功，最后再广播一次(这是多么的自恋啊)，这次只广播block的hash。</p>
<p>总结<br>fetcher.go 作为以太坊同步区块的一个辅助类，它的职责就是层层把关，层层过滤，抵制无效的区块进入，杜绝无用的同步请求。这块代码很多很乱，第一次看可能会有点晕，第二次看可能还是很晕，多看几次可能还会晕😄，不过只要知道它做什么就好了。</p>
<h4 id="Downloader"><a href="#Downloader" class="headerlink" title="Downloader"></a>Downloader</h4><p>一，启动Downloader<br>ProtocolManager初始化的时候会进行Downloader的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func New(mode SyncMode, stateDb ethdb.Database, mux *event.TypeMux, chain BlockChain, lightchain LightChain, dropPeer peerDropFn) *Downloader &#123;</span><br><span class="line">    if lightchain == nil &#123;</span><br><span class="line">        lightchain = chain</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dl := &amp;Downloader&#123;</span><br><span class="line">        mode:           mode,</span><br><span class="line">        stateDB:        stateDb,</span><br><span class="line">        mux:            mux,</span><br><span class="line">        queue:          newQueue(),</span><br><span class="line">        peers:          newPeerSet(),</span><br><span class="line">        rttEstimate:    uint64(rttMaxEstimate),</span><br><span class="line">        rttConfidence:  uint64(1000000),</span><br><span class="line">        blockchain:     chain,</span><br><span class="line">        lightchain:     lightchain,</span><br><span class="line">        dropPeer:       dropPeer,</span><br><span class="line">        headerCh:       make(chan dataPack, 1),</span><br><span class="line">        bodyCh:         make(chan dataPack, 1),</span><br><span class="line">        receiptCh:      make(chan dataPack, 1),</span><br><span class="line">        bodyWakeCh:     make(chan bool, 1),</span><br><span class="line">        receiptWakeCh:  make(chan bool, 1),</span><br><span class="line">        headerProcCh:   make(chan []*types.Header, 1),</span><br><span class="line">        quitCh:         make(chan struct&#123;&#125;),</span><br><span class="line">        stateCh:        make(chan dataPack),</span><br><span class="line">        stateSyncStart: make(chan *stateSync),</span><br><span class="line">        trackStateReq:  make(chan *stateReq),</span><br><span class="line">    &#125;</span><br><span class="line">    go dl.qosTuner()</span><br><span class="line">    go dl.stateFetcher()</span><br><span class="line">    return dl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先初始化Downloader对象的成员，然后启动dl.qosTuner() goroutine计算请求回路时间，启动dl.stateFetcher() goroutine 开启Downloader状态监控。</p>
<p>ProtocolManager收到新的区块消息广播或者有新的P2P网络节点加入的时候会调用ProtocolManager的 synchronise(peer *peer)方法，这时候会调用Downloader的Synchronise(peer.id, pHead, pTd, mode)方法。</p>
<p>Synchronise方法，重置d.queue和d.peers，清空d.bodyWakeCh, d.receiptWakeCh，d.headerCh, d.bodyCh, d.receiptCh，d.headerProcCh。调用d.syncWithPeer(p, hash, td)方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">func (d *Downloader) syncWithPeer(p *peerConnection, hash common.Hash, td *big.Int) (err error) &#123;</span><br><span class="line">    d.mux.Post(StartEvent&#123;&#125;)</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        // reset on error</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            d.mux.Post(FailedEvent&#123;err&#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            d.mux.Post(DoneEvent&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    if p.version &lt; 62 &#123;</span><br><span class="line">        return errTooOld</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Debug(&quot;Synchronising with the network&quot;, &quot;peer&quot;, p.id, &quot;eth&quot;, p.version, &quot;head&quot;, hash, &quot;td&quot;, td, &quot;mode&quot;, d.mode)</span><br><span class="line">    defer func(start time.Time) &#123;</span><br><span class="line">        log.Debug(&quot;Synchronisation terminated&quot;, &quot;elapsed&quot;, time.Since(start))</span><br><span class="line">    &#125;(time.Now())</span><br><span class="line"></span><br><span class="line">    // Look up the sync boundaries: the common ancestor and the target block</span><br><span class="line">    latest, err := d.fetchHeight(p)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    height := latest.Number.Uint64()</span><br><span class="line"></span><br><span class="line">    origin, err := d.findAncestor(p, height)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    d.syncStatsLock.Lock()</span><br><span class="line">    if d.syncStatsChainHeight &lt;= origin || d.syncStatsChainOrigin &gt; origin &#123;</span><br><span class="line">        d.syncStatsChainOrigin = origin</span><br><span class="line">    &#125;</span><br><span class="line">    d.syncStatsChainHeight = height</span><br><span class="line">    d.syncStatsLock.Unlock()</span><br><span class="line"></span><br><span class="line">    // Ensure our origin point is below any fast sync pivot point</span><br><span class="line">    pivot := uint64(0)</span><br><span class="line">    if d.mode == FastSync &#123;</span><br><span class="line">        if height &lt;= uint64(fsMinFullBlocks) &#123;</span><br><span class="line">            origin = 0</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pivot = height - uint64(fsMinFullBlocks)</span><br><span class="line">            if pivot &lt;= origin &#123;</span><br><span class="line">                origin = pivot - 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d.committed = 1</span><br><span class="line">    if d.mode == FastSync &amp;&amp; pivot != 0 &#123;</span><br><span class="line">        d.committed = 0</span><br><span class="line">    &#125;</span><br><span class="line">    // Initiate the sync using a concurrent header and content retrieval algorithm</span><br><span class="line">    d.queue.Prepare(origin+1, d.mode)</span><br><span class="line">    if d.syncInitHook != nil &#123;</span><br><span class="line">        d.syncInitHook(origin, height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fetchers := []func() error&#123;</span><br><span class="line">        func() error &#123; return d.fetchHeaders(p, origin+1, pivot) &#125;, // Headers are always retrieved</span><br><span class="line">        func() error &#123; return d.fetchBodies(origin + 1) &#125;,          // Bodies are retrieved during normal and fast sync</span><br><span class="line">        func() error &#123; return d.fetchReceipts(origin + 1) &#125;,        // Receipts are retrieved during fast sync</span><br><span class="line">        func() error &#123; return d.processHeaders(origin+1, pivot, td) &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    if d.mode == FastSync &#123;</span><br><span class="line">        fetchers = append(fetchers, func() error &#123; return d.processFastSyncContent(latest) &#125;)</span><br><span class="line">    &#125; else if d.mode == FullSync &#123;</span><br><span class="line">        fetchers = append(fetchers, d.processFullSyncContent)</span><br><span class="line">    &#125;</span><br><span class="line">    return d.spawnSync(fetchers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用latest, err := d.fetchHeight(p)获取到peer节点最新的区块头,这个方法有点绕，我们来分析一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func (d *Downloader) fetchHeight(p *peerConnection) (*types.Header, error) &#123;</span><br><span class="line">    p.log.Debug(&quot;Retrieving remote chain height&quot;)</span><br><span class="line"></span><br><span class="line">    // Request the advertised remote head block and wait for the response</span><br><span class="line">    head, _ := p.peer.Head()</span><br><span class="line">    go p.peer.RequestHeadersByHash(head, 1, 0, false)</span><br><span class="line"></span><br><span class="line">    ttl := d.requestTTL()</span><br><span class="line">    timeout := time.After(ttl)</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-d.cancelCh:</span><br><span class="line">            return nil, errCancelBlockFetch</span><br><span class="line"></span><br><span class="line">        case packet := &lt;-d.headerCh:</span><br><span class="line">            // Discard anything not from the origin peer</span><br><span class="line">            if packet.PeerId() != p.id &#123;</span><br><span class="line">                log.Debug(&quot;Received headers from incorrect peer&quot;, &quot;peer&quot;, packet.PeerId())</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            // Make sure the peer actually gave something valid</span><br><span class="line">            headers := packet.(*headerPack).headers</span><br><span class="line">            if len(headers) != 1 &#123;</span><br><span class="line">                p.log.Debug(&quot;Multiple headers for single request&quot;, &quot;headers&quot;, len(headers))</span><br><span class="line">                return nil, errBadPeer</span><br><span class="line">            &#125;</span><br><span class="line">            head := headers[0]</span><br><span class="line">            p.log.Debug(&quot;Remote head header identified&quot;, &quot;number&quot;, head.Number, &quot;hash&quot;, head.Hash())</span><br><span class="line">            return head, nil</span><br><span class="line"></span><br><span class="line">        case &lt;-timeout:</span><br><span class="line">            p.log.Debug(&quot;Waiting for head header timed out&quot;, &quot;elapsed&quot;, ttl)</span><br><span class="line">            return nil, errTimeout</span><br><span class="line"></span><br><span class="line">        case &lt;-d.bodyCh:</span><br><span class="line">        case &lt;-d.receiptCh:</span><br><span class="line">            // Out of bounds delivery, ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1，调用peer.RequestHeadersByHash(head, 1, 0, false)，给网络节点发送一个GetBlockHeadersMsg的消息<br>2，然后阻塞住线程，直到收到d.headerCh或者timeout<br>3，本地节点会收到网络节点的BlockHeadersMsg的消息返回<br>4，调用downloader.DeliverHeaders(p.id, headers)<br>5，这时候会把p.id和headers打包发送给d.headerCh<br>6，这时候select收到d.headerCh，阻塞打开，并返回header内容</p>
<p>syncWithPeer() 方法接着调用 d.findAncestor(p, height)来获取本地节点和网络节点共同的祖先：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">func (d *Downloader) findAncestor(p *peerConnection, height uint64) (uint64, error) &#123;</span><br><span class="line">    // Figure out the valid ancestor range to prevent rewrite attacks</span><br><span class="line">    floor, ceil := int64(-1), d.lightchain.CurrentHeader().Number.Uint64()</span><br><span class="line"></span><br><span class="line">    if d.mode == FullSync &#123;</span><br><span class="line">        ceil = d.blockchain.CurrentBlock().NumberU64()</span><br><span class="line">    &#125; else if d.mode == FastSync &#123;</span><br><span class="line">        ceil = d.blockchain.CurrentFastBlock().NumberU64()</span><br><span class="line">    &#125;</span><br><span class="line">    if ceil &gt;= MaxForkAncestry &#123;</span><br><span class="line">        floor = int64(ceil - MaxForkAncestry)</span><br><span class="line">    &#125;</span><br><span class="line">    p.log.Debug(&quot;Looking for common ancestor&quot;, &quot;local&quot;, ceil, &quot;remote&quot;, height)</span><br><span class="line"></span><br><span class="line">    // Request the topmost blocks to short circuit binary ancestor lookup</span><br><span class="line">    head := ceil</span><br><span class="line">    if head &gt; height &#123;</span><br><span class="line">        head = height</span><br><span class="line">    &#125;</span><br><span class="line">    from := int64(head) - int64(MaxHeaderFetch)</span><br><span class="line">    if from &lt; 0 &#123;</span><br><span class="line">        from = 0</span><br><span class="line">    &#125;</span><br><span class="line">    // Span out with 15 block gaps into the future to catch bad head reports</span><br><span class="line">    limit := 2 * MaxHeaderFetch / 16</span><br><span class="line">    count := 1 + int((int64(ceil)-from)/16)</span><br><span class="line">    if count &gt; limit &#123;</span><br><span class="line">        count = limit</span><br><span class="line">    &#125;</span><br><span class="line">    go p.peer.RequestHeadersByNumber(uint64(from), count, 15, false)</span><br><span class="line"></span><br><span class="line">    // Wait for the remote response to the head fetch</span><br><span class="line">    number, hash := uint64(0), common.Hash&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ttl := d.requestTTL()</span><br><span class="line">    timeout := time.After(ttl)</span><br><span class="line"></span><br><span class="line">    for finished := false; !finished; &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-d.cancelCh:</span><br><span class="line">            return 0, errCancelHeaderFetch</span><br><span class="line"></span><br><span class="line">        case packet := &lt;-d.headerCh:</span><br><span class="line">            // Discard anything not from the origin peer</span><br><span class="line">            if packet.PeerId() != p.id &#123;</span><br><span class="line">                log.Debug(&quot;Received headers from incorrect peer&quot;, &quot;peer&quot;, packet.PeerId())</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            // Make sure the peer actually gave something valid</span><br><span class="line">            headers := packet.(*headerPack).headers</span><br><span class="line">            if len(headers) == 0 &#123;</span><br><span class="line">                p.log.Warn(&quot;Empty head header set&quot;)</span><br><span class="line">                return 0, errEmptyHeaderSet</span><br><span class="line">            &#125;</span><br><span class="line">            // Make sure the peer&apos;s reply conforms to the request</span><br><span class="line">            for i := 0; i &lt; len(headers); i++ &#123;</span><br><span class="line">                if number := headers[i].Number.Int64(); number != from+int64(i)*16 &#123;</span><br><span class="line">                    p.log.Warn(&quot;Head headers broke chain ordering&quot;, &quot;index&quot;, i, &quot;requested&quot;, from+int64(i)*16, &quot;received&quot;, number)</span><br><span class="line">                    return 0, errInvalidChain</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // Check if a common ancestor was found</span><br><span class="line">            finished = true</span><br><span class="line">            for i := len(headers) - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">                // Skip any headers that underflow/overflow our requested set</span><br><span class="line">                if headers[i].Number.Int64() &lt; from || headers[i].Number.Uint64() &gt; ceil &#123;</span><br><span class="line">                    continue</span><br><span class="line">                &#125;</span><br><span class="line">                // Otherwise check if we already know the header or not</span><br><span class="line">                if (d.mode == FullSync &amp;&amp; d.blockchain.HasBlock(headers[i].Hash(), headers[i].Number.Uint64())) || (d.mode != FullSync &amp;&amp; d.lightchain.HasHeader(headers[i].Hash(), headers[i].Number.Uint64())) &#123;</span><br><span class="line">                    number, hash = headers[i].Number.Uint64(), headers[i].Hash()</span><br><span class="line"></span><br><span class="line">                    // If every header is known, even future ones, the peer straight out lied about its head</span><br><span class="line">                    if number &gt; height &amp;&amp; i == limit-1 &#123;</span><br><span class="line">                        p.log.Warn(&quot;Lied about chain head&quot;, &quot;reported&quot;, height, &quot;found&quot;, number)</span><br><span class="line">                        return 0, errStallingPeer</span><br><span class="line">                    &#125;</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        case &lt;-timeout:</span><br><span class="line">            p.log.Debug(&quot;Waiting for head header timed out&quot;, &quot;elapsed&quot;, ttl)</span><br><span class="line">            return 0, errTimeout</span><br><span class="line"></span><br><span class="line">        case &lt;-d.bodyCh:</span><br><span class="line">        case &lt;-d.receiptCh:</span><br><span class="line">            // Out of bounds delivery, ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If the head fetch already found an ancestor, return</span><br><span class="line">    if !common.EmptyHash(hash) &#123;</span><br><span class="line">        if int64(number) &lt;= floor &#123;</span><br><span class="line">            p.log.Warn(&quot;Ancestor below allowance&quot;, &quot;number&quot;, number, &quot;hash&quot;, hash, &quot;allowance&quot;, floor)</span><br><span class="line">            return 0, errInvalidAncestor</span><br><span class="line">        &#125;</span><br><span class="line">        p.log.Debug(&quot;Found common ancestor&quot;, &quot;number&quot;, number, &quot;hash&quot;, hash)</span><br><span class="line">        return number, nil</span><br><span class="line">    &#125;</span><br><span class="line">    // Ancestor not found, we need to binary search over our chain</span><br><span class="line">    start, end := uint64(0), head</span><br><span class="line">    if floor &gt; 0 &#123;</span><br><span class="line">        start = uint64(floor)</span><br><span class="line">    &#125;</span><br><span class="line">    for start+1 &lt; end &#123;</span><br><span class="line">        // Split our chain interval in two, and request the hash to cross check</span><br><span class="line">        check := (start + end) / 2</span><br><span class="line"></span><br><span class="line">        ttl := d.requestTTL()</span><br><span class="line">        timeout := time.After(ttl)</span><br><span class="line"></span><br><span class="line">        go p.peer.RequestHeadersByNumber(check, 1, 0, false)</span><br><span class="line"></span><br><span class="line">        // Wait until a reply arrives to this request</span><br><span class="line">        for arrived := false; !arrived; &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-d.cancelCh:</span><br><span class="line">                return 0, errCancelHeaderFetch</span><br><span class="line"></span><br><span class="line">            case packer := &lt;-d.headerCh:</span><br><span class="line">                // Discard anything not from the origin peer</span><br><span class="line">                if packer.PeerId() != p.id &#123;</span><br><span class="line">                    log.Debug(&quot;Received headers from incorrect peer&quot;, &quot;peer&quot;, packer.PeerId())</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">                // Make sure the peer actually gave something valid</span><br><span class="line">                headers := packer.(*headerPack).headers</span><br><span class="line">                if len(headers) != 1 &#123;</span><br><span class="line">                    p.log.Debug(&quot;Multiple headers for single request&quot;, &quot;headers&quot;, len(headers))</span><br><span class="line">                    return 0, errBadPeer</span><br><span class="line">                &#125;</span><br><span class="line">                arrived = true</span><br><span class="line"></span><br><span class="line">                // Modify the search interval based on the response</span><br><span class="line">                if (d.mode == FullSync &amp;&amp; !d.blockchain.HasBlock(headers[0].Hash(), headers[0].Number.Uint64())) || (d.mode != FullSync &amp;&amp; !d.lightchain.HasHeader(headers[0].Hash(), headers[0].Number.Uint64())) &#123;</span><br><span class="line">                    end = check</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">                header := d.lightchain.GetHeaderByHash(headers[0].Hash()) // Independent of sync mode, header surely exists</span><br><span class="line">                if header.Number.Uint64() != check &#123;</span><br><span class="line">                    p.log.Debug(&quot;Received non requested header&quot;, &quot;number&quot;, header.Number, &quot;hash&quot;, header.Hash(), &quot;request&quot;, check)</span><br><span class="line">                    return 0, errBadPeer</span><br><span class="line">                &#125;</span><br><span class="line">                start = check</span><br><span class="line"></span><br><span class="line">            case &lt;-timeout:</span><br><span class="line">                p.log.Debug(&quot;Waiting for search header timed out&quot;, &quot;elapsed&quot;, ttl)</span><br><span class="line">                return 0, errTimeout</span><br><span class="line"></span><br><span class="line">            case &lt;-d.bodyCh:</span><br><span class="line">            case &lt;-d.receiptCh:</span><br><span class="line">                // Out of bounds delivery, ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Ensure valid ancestry and return</span><br><span class="line">    if int64(start) &lt;= floor &#123;</span><br><span class="line">        p.log.Warn(&quot;Ancestor below allowance&quot;, &quot;number&quot;, start, &quot;hash&quot;, hash, &quot;allowance&quot;, floor)</span><br><span class="line">        return 0, errInvalidAncestor</span><br><span class="line">    &#125;</span><br><span class="line">    p.log.Debug(&quot;Found common ancestor&quot;, &quot;number&quot;, start, &quot;hash&quot;, hash)</span><br><span class="line">    return start, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1，调用peer.RequestHeadersByNumber(uint64(from), count, 15, false)，获取header。这里传入 count和 15，指从本地最高的header往前数192个区块的头，每16个区块取一个区块头。为了后面select收到d.headerCh时加以验证。<br>2，select收到了headers，遍历header，看是否在本地是否存在这个header，如果有，并且不为空，就说明找到共同的祖先，返回祖先number<br>3，如果没有找到共同的祖先，再重新从本地的区块链MaxForkAncestry起的一半的位置开始取区块头，一一验证是否跟网络节点返回的header一致，如果有就说明有共同的祖先，并返回，没有的话就返回0.</p>
<p>继续syncWithPeer()方法，找到同步的轴心的pivot，最后把要同步的数据和同步的方法传给d.spawnSync(fetchers)，并执行。d.spawnSync(fetchers)挨个执行传入的同步方法。</p>
<p>二，Downloader同步数据方法<br>fetchHeaders()，fetchBodies() , fetchReceipts()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">func (d *Downloader) fetchHeaders(p *peerConnection, from uint64, pivot uint64) error &#123;</span><br><span class="line">    p.log.Debug(&quot;Directing header downloads&quot;, &quot;origin&quot;, from)</span><br><span class="line">    defer p.log.Debug(&quot;Header download terminated&quot;)</span><br><span class="line"></span><br><span class="line">    // Create a timeout timer, and the associated header fetcher</span><br><span class="line">    skeleton := true            // Skeleton assembly phase or finishing up</span><br><span class="line">    request := time.Now()       // time of the last skeleton fetch request</span><br><span class="line">    timeout := time.NewTimer(0) // timer to dump a non-responsive active peer</span><br><span class="line">    &lt;-timeout.C                 // timeout channel should be initially empty</span><br><span class="line">    defer timeout.Stop()</span><br><span class="line"></span><br><span class="line">    var ttl time.Duration</span><br><span class="line">    getHeaders := func(from uint64) &#123;</span><br><span class="line">        request = time.Now()</span><br><span class="line"></span><br><span class="line">        ttl = d.requestTTL()</span><br><span class="line">        timeout.Reset(ttl)</span><br><span class="line"></span><br><span class="line">        if skeleton &#123;</span><br><span class="line">            p.log.Trace(&quot;Fetching skeleton headers&quot;, &quot;count&quot;, MaxHeaderFetch, &quot;from&quot;, from)</span><br><span class="line">            go p.peer.RequestHeadersByNumber(from+uint64(MaxHeaderFetch)-1, MaxSkeletonSize, MaxHeaderFetch-1, false)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p.log.Trace(&quot;Fetching full headers&quot;, &quot;count&quot;, MaxHeaderFetch, &quot;from&quot;, from)</span><br><span class="line">            go p.peer.RequestHeadersByNumber(from, MaxHeaderFetch, 0, false)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Start pulling the header chain skeleton until all is done</span><br><span class="line">    getHeaders(from)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-d.cancelCh:</span><br><span class="line">            return errCancelHeaderFetch</span><br><span class="line"></span><br><span class="line">        case packet := &lt;-d.headerCh:</span><br><span class="line">            // Make sure the active peer is giving us the skeleton headers</span><br><span class="line">            if packet.PeerId() != p.id &#123;</span><br><span class="line">                log.Debug(&quot;Received skeleton from incorrect peer&quot;, &quot;peer&quot;, packet.PeerId())</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            headerReqTimer.UpdateSince(request)</span><br><span class="line">            timeout.Stop()</span><br><span class="line"></span><br><span class="line">            // If the skeleton&apos;s finished, pull any remaining head headers directly from the origin</span><br><span class="line">            if packet.Items() == 0 &amp;&amp; skeleton &#123;</span><br><span class="line">                skeleton = false</span><br><span class="line">                getHeaders(from)</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            // If no more headers are inbound, notify the content fetchers and return</span><br><span class="line">            if packet.Items() == 0 &#123;</span><br><span class="line">                // Don&apos;t abort header fetches while the pivot is downloading</span><br><span class="line">                if atomic.LoadInt32(&amp;d.committed) == 0 &amp;&amp; pivot &lt;= from &#123;</span><br><span class="line">                    p.log.Debug(&quot;No headers, waiting for pivot commit&quot;)</span><br><span class="line">                    select &#123;</span><br><span class="line">                    case &lt;-time.After(fsHeaderContCheck):</span><br><span class="line">                        getHeaders(from)</span><br><span class="line">                        continue</span><br><span class="line">                    case &lt;-d.cancelCh:</span><br><span class="line">                        return errCancelHeaderFetch</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // Pivot done (or not in fast sync) and no more headers, terminate the process</span><br><span class="line">                p.log.Debug(&quot;No more headers available&quot;)</span><br><span class="line">                select &#123;</span><br><span class="line">                case d.headerProcCh &lt;- nil:</span><br><span class="line">                    return nil</span><br><span class="line">                case &lt;-d.cancelCh:</span><br><span class="line">                    return errCancelHeaderFetch</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            headers := packet.(*headerPack).headers</span><br><span class="line"></span><br><span class="line">            // If we received a skeleton batch, resolve internals concurrently</span><br><span class="line">            if skeleton &#123;</span><br><span class="line">                filled, proced, err := d.fillHeaderSkeleton(from, headers)</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                    p.log.Debug(&quot;Skeleton chain invalid&quot;, &quot;err&quot;, err)</span><br><span class="line">                    return errInvalidChain</span><br><span class="line">                &#125;</span><br><span class="line">                headers = filled[proced:]</span><br><span class="line">                from += uint64(proced)</span><br><span class="line">            &#125;</span><br><span class="line">            // Insert all the new headers and fetch the next batch</span><br><span class="line">            if len(headers) &gt; 0 &#123;</span><br><span class="line">                p.log.Trace(&quot;Scheduling new headers&quot;, &quot;count&quot;, len(headers), &quot;from&quot;, from)</span><br><span class="line">                select &#123;</span><br><span class="line">                case d.headerProcCh &lt;- headers:</span><br><span class="line">                case &lt;-d.cancelCh:</span><br><span class="line">                    return errCancelHeaderFetch</span><br><span class="line">                &#125;</span><br><span class="line">                from += uint64(len(headers))</span><br><span class="line">            &#125;</span><br><span class="line">            getHeaders(from)</span><br><span class="line"></span><br><span class="line">        case &lt;-timeout.C:</span><br><span class="line">            if d.dropPeer == nil &#123;</span><br><span class="line">                // The dropPeer method is nil when `--copydb` is used for a local copy.</span><br><span class="line">                // Timeouts can occur if e.g. compaction hits at the wrong time, and can be ignored</span><br><span class="line">                p.log.Warn(&quot;Downloader wants to drop peer, but peerdrop-function is not set&quot;, &quot;peer&quot;, p.id)</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            // Header retrieval timed out, consider the peer bad and drop</span><br><span class="line">            p.log.Debug(&quot;Header request timed out&quot;, &quot;elapsed&quot;, ttl)</span><br><span class="line">            headerTimeoutMeter.Mark(1)</span><br><span class="line">            d.dropPeer(p.id)</span><br><span class="line"></span><br><span class="line">            // Finish the sync gracefully instead of dumping the gathered data though</span><br><span class="line">            for _, ch := range []chan bool&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case ch &lt;- false:</span><br><span class="line">                case &lt;-d.cancelCh:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            select &#123;</span><br><span class="line">            case d.headerProcCh &lt;- nil:</span><br><span class="line">            case &lt;-d.cancelCh:</span><br><span class="line">            &#125;</span><br><span class="line">            return errBadPeer</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1，getHeaders()调用peer.RequestHeadersByNumber()方法 获取网络节点的headers。<br>2，有两种获取方式，首先走的是skeleton方式，从查找到的共同祖先区块+192个区块位置开始，每隔192个区块，获取128个区块头。非skeleton方式，从共同祖先区块开始，获取192个区块头。<br>3，如果第一种方式获取不到区块头，则执行第二种获取方式，如果第二种方式还是没有获取到区块头的话，直接返回<br>4，如果是skeleton获取到的，调用fillHeaderSkeleton()方法加入到skeleton header chain<br>5，然后调整from值，再递归调用getHeaders()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func (d *Downloader) fillHeaderSkeleton(from uint64, skeleton []*types.Header) ([]*types.Header, int, error) &#123;</span><br><span class="line">    log.Debug(&quot;Filling up skeleton&quot;, &quot;from&quot;, from)</span><br><span class="line">    d.queue.ScheduleSkeleton(from, skeleton)</span><br><span class="line"></span><br><span class="line">    var (</span><br><span class="line">        deliver = func(packet dataPack) (int, error) &#123;</span><br><span class="line">            pack := packet.(*headerPack)</span><br><span class="line">            return d.queue.DeliverHeaders(pack.peerId, pack.headers, d.headerProcCh)</span><br><span class="line">        &#125;</span><br><span class="line">        expire   = func() map[string]int &#123; return d.queue.ExpireHeaders(d.requestTTL()) &#125;</span><br><span class="line">        throttle = func() bool &#123; return false &#125;</span><br><span class="line">        reserve  = func(p *peerConnection, count int) (*fetchRequest, bool, error) &#123;</span><br><span class="line">            return d.queue.ReserveHeaders(p, count), false, nil</span><br><span class="line">        &#125;</span><br><span class="line">        fetch    = func(p *peerConnection, req *fetchRequest) error &#123; return p.FetchHeaders(req.From, MaxHeaderFetch) &#125;</span><br><span class="line">        capacity = func(p *peerConnection) int &#123; return p.HeaderCapacity(d.requestRTT()) &#125;</span><br><span class="line">        setIdle  = func(p *peerConnection, accepted int) &#123; p.SetHeadersIdle(accepted) &#125;</span><br><span class="line">    )</span><br><span class="line">    err := d.fetchParts(errCancelHeaderFetch, d.headerCh, deliver, d.queue.headerContCh, expire,</span><br><span class="line">        d.queue.PendingHeaders, d.queue.InFlightHeaders, throttle, reserve,</span><br><span class="line">        nil, fetch, d.queue.CancelHeaders, capacity, d.peers.HeaderIdlePeers, setIdle, &quot;headers&quot;)</span><br><span class="line"></span><br><span class="line">    log.Debug(&quot;Skeleton fill terminated&quot;, &quot;err&quot;, err)</span><br><span class="line"></span><br><span class="line">    filled, proced := d.queue.RetrieveHeaders()</span><br><span class="line">    return filled, proced, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a) 把skeleton的headers加入queue.ScheduleSkeleton调度队列，<br>b) 然后执行d.fetchParts()方法。<br>d.fetchParts()方法主要做了这几件事情<br>1，对收到的headers执行d.queue.DeliverHeaders()方法。<br>2，如果d.queue.PendingHeaders有pending的headers，调用d.peers.HeaderIdlePeers获取到idle的peers<br>3，调用d.queue.ReserveHeaders把pending的headers储备到idle的peers里面<br>4，用idle的peers调用p.FetchHeaders(req.From, MaxHeaderFetch)去获取headers<br>c) 最后执行d.queue.RetrieveHeaders()，获取到filled进去的headers</p>
<p>其他同步区块数据的方法d.fetchBodies() , d.fetchReceipts() 和fetchHeaders()流程类似，还更简单一些。</p>
<p>三，Downloader同步数据过程<br>d.processHeaders(), d.processFastSyncContent(latest) , d.processFullSyncContent<br>1，d.processHeaders() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">func (d *Downloader) processHeaders(origin uint64, pivot uint64, td *big.Int) error &#123;</span><br><span class="line">    // Keep a count of uncertain headers to roll back</span><br><span class="line">    rollback := []*types.Header&#123;&#125;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if len(rollback) &gt; 0 &#123;</span><br><span class="line">            // Flatten the headers and roll them back</span><br><span class="line">            hashes := make([]common.Hash, len(rollback))</span><br><span class="line">            for i, header := range rollback &#123;</span><br><span class="line">                hashes[i] = header.Hash()</span><br><span class="line">            &#125;</span><br><span class="line">            lastHeader, lastFastBlock, lastBlock := d.lightchain.CurrentHeader().Number, common.Big0, common.Big0</span><br><span class="line">            if d.mode != LightSync &#123;</span><br><span class="line">                lastFastBlock = d.blockchain.CurrentFastBlock().Number()</span><br><span class="line">                lastBlock = d.blockchain.CurrentBlock().Number()</span><br><span class="line">            &#125;</span><br><span class="line">            d.lightchain.Rollback(hashes)</span><br><span class="line">            curFastBlock, curBlock := common.Big0, common.Big0</span><br><span class="line">            if d.mode != LightSync &#123;</span><br><span class="line">                curFastBlock = d.blockchain.CurrentFastBlock().Number()</span><br><span class="line">                curBlock = d.blockchain.CurrentBlock().Number()</span><br><span class="line">            &#125;</span><br><span class="line">            log.Warn(&quot;Rolled back headers&quot;, &quot;count&quot;, len(hashes),</span><br><span class="line">                &quot;header&quot;, fmt.Sprintf(&quot;%d-&gt;%d&quot;, lastHeader, d.lightchain.CurrentHeader().Number),</span><br><span class="line">                &quot;fast&quot;, fmt.Sprintf(&quot;%d-&gt;%d&quot;, lastFastBlock, curFastBlock),</span><br><span class="line">                &quot;block&quot;, fmt.Sprintf(&quot;%d-&gt;%d&quot;, lastBlock, curBlock))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    // Wait for batches of headers to process</span><br><span class="line">    gotHeaders := false</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-d.cancelCh:</span><br><span class="line">            return errCancelHeaderProcessing</span><br><span class="line"></span><br><span class="line">        case headers := &lt;-d.headerProcCh:</span><br><span class="line">            // Terminate header processing if we synced up</span><br><span class="line">            if len(headers) == 0 &#123;</span><br><span class="line">                // Notify everyone that headers are fully processed</span><br><span class="line">                for _, ch := range []chan bool&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">                    select &#123;</span><br><span class="line">                    case ch &lt;- false:</span><br><span class="line">                    case &lt;-d.cancelCh:</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if d.mode != LightSync &#123;</span><br><span class="line">                    head := d.blockchain.CurrentBlock()</span><br><span class="line">                    if !gotHeaders &amp;&amp; td.Cmp(d.blockchain.GetTd(head.Hash(), head.NumberU64())) &gt; 0 &#123;</span><br><span class="line">                        return errStallingPeer</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if d.mode == FastSync || d.mode == LightSync &#123;</span><br><span class="line">                    head := d.lightchain.CurrentHeader()</span><br><span class="line">                    if td.Cmp(d.lightchain.GetTd(head.Hash(), head.Number.Uint64())) &gt; 0 &#123;</span><br><span class="line">                        return errStallingPeer</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // Disable any rollback and return</span><br><span class="line">                rollback = nil</span><br><span class="line">                return nil</span><br><span class="line">            &#125;</span><br><span class="line">            // Otherwise split the chunk of headers into batches and process them</span><br><span class="line">            gotHeaders = true</span><br><span class="line"></span><br><span class="line">            for len(headers) &gt; 0 &#123;</span><br><span class="line">                // Terminate if something failed in between processing chunks</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-d.cancelCh:</span><br><span class="line">                    return errCancelHeaderProcessing</span><br><span class="line">                default:</span><br><span class="line">                &#125;</span><br><span class="line">                // Select the next chunk of headers to import</span><br><span class="line">                limit := maxHeadersProcess</span><br><span class="line">                if limit &gt; len(headers) &#123;</span><br><span class="line">                    limit = len(headers)</span><br><span class="line">                &#125;</span><br><span class="line">                chunk := headers[:limit]</span><br><span class="line"></span><br><span class="line">                // In case of header only syncing, validate the chunk immediately</span><br><span class="line">                if d.mode == FastSync || d.mode == LightSync &#123;</span><br><span class="line">                    // Collect the yet unknown headers to mark them as uncertain</span><br><span class="line">                    unknown := make([]*types.Header, 0, len(headers))</span><br><span class="line">                    for _, header := range chunk &#123;</span><br><span class="line">                        if !d.lightchain.HasHeader(header.Hash(), header.Number.Uint64()) &#123;</span><br><span class="line">                            unknown = append(unknown, header)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // If we&apos;re importing pure headers, verify based on their recentness</span><br><span class="line">                    frequency := fsHeaderCheckFrequency</span><br><span class="line">                    if chunk[len(chunk)-1].Number.Uint64()+uint64(fsHeaderForceVerify) &gt; pivot &#123;</span><br><span class="line">                        frequency = 1</span><br><span class="line">                    &#125;</span><br><span class="line">                    if n, err := d.lightchain.InsertHeaderChain(chunk, frequency); err != nil &#123;</span><br><span class="line">                        // If some headers were inserted, add them too to the rollback list</span><br><span class="line">                        if n &gt; 0 &#123;</span><br><span class="line">                            rollback = append(rollback, chunk[:n]...)</span><br><span class="line">                        &#125;</span><br><span class="line">                        log.Debug(&quot;Invalid header encountered&quot;, &quot;number&quot;, chunk[n].Number, &quot;hash&quot;, chunk[n].Hash(), &quot;err&quot;, err)</span><br><span class="line">                        return errInvalidChain</span><br><span class="line">                    &#125;</span><br><span class="line">                    // All verifications passed, store newly found uncertain headers</span><br><span class="line">                    rollback = append(rollback, unknown...)</span><br><span class="line">                    if len(rollback) &gt; fsHeaderSafetyNet &#123;</span><br><span class="line">                        rollback = append(rollback[:0], rollback[len(rollback)-fsHeaderSafetyNet:]...)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // Unless we&apos;re doing light chains, schedule the headers for associated content retrieval</span><br><span class="line">                if d.mode == FullSync || d.mode == FastSync &#123;</span><br><span class="line">                    // If we&apos;ve reached the allowed number of pending headers, stall a bit</span><br><span class="line">                    for d.queue.PendingBlocks() &gt;= maxQueuedHeaders || d.queue.PendingReceipts() &gt;= maxQueuedHeaders &#123;</span><br><span class="line">                        select &#123;</span><br><span class="line">                        case &lt;-d.cancelCh:</span><br><span class="line">                            return errCancelHeaderProcessing</span><br><span class="line">                        case &lt;-time.After(time.Second):</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Otherwise insert the headers for content retrieval</span><br><span class="line">                    inserts := d.queue.Schedule(chunk, origin)</span><br><span class="line">                    if len(inserts) != len(chunk) &#123;</span><br><span class="line">                        log.Debug(&quot;Stale headers&quot;)</span><br><span class="line">                        return errBadPeer</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                headers = headers[limit:]</span><br><span class="line">                origin += uint64(limit)</span><br><span class="line">            &#125;</span><br><span class="line">            // Signal the content downloaders of the availablility of new tasks</span><br><span class="line">            for _, ch := range []chan bool&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case ch &lt;- true:</span><br><span class="line">                default:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1，收到从fetchHeaders()方法 中d.headerProcCh发送过来的headers<br>2，如果是FastSync或者LightSync模式，直接调用lightchain.InsertHeaderChain(chunk, frequency)插入到headerChain。<br>3，如果是FullSync或者FastSyn模式，调用d.queue.Schedule(chunk, origin)，放入downloader.queue来调度</p>
<p>2，processFastSyncContent() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">func (d *Downloader) processFastSyncContent(latest *types.Header) error &#123;</span><br><span class="line">    // Start syncing state of the reported head block. This should get us most of</span><br><span class="line">    // the state of the pivot block.</span><br><span class="line">    stateSync := d.syncState(latest.Root)</span><br><span class="line">    defer stateSync.Cancel()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err := stateSync.Wait(); err != nil &amp;&amp; err != errCancelStateFetch &#123;</span><br><span class="line">            d.queue.Close() // wake up WaitResults</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    // Figure out the ideal pivot block. Note, that this goalpost may move if the</span><br><span class="line">    // sync takes long enough for the chain head to move significantly.</span><br><span class="line">    pivot := uint64(0)</span><br><span class="line">    if height := latest.Number.Uint64(); height &gt; uint64(fsMinFullBlocks) &#123;</span><br><span class="line">        pivot = height - uint64(fsMinFullBlocks)</span><br><span class="line">    &#125;</span><br><span class="line">    // To cater for moving pivot points, track the pivot block and subsequently</span><br><span class="line">    // accumulated download results separatey.</span><br><span class="line">    var (</span><br><span class="line">        oldPivot *fetchResult   // Locked in pivot block, might change eventually</span><br><span class="line">        oldTail  []*fetchResult // Downloaded content after the pivot</span><br><span class="line">    )</span><br><span class="line">    for &#123;</span><br><span class="line">        // Wait for the next batch of downloaded data to be available, and if the pivot</span><br><span class="line">        // block became stale, move the goalpost</span><br><span class="line">        results := d.queue.Results(oldPivot == nil) // Block if we&apos;re not monitoring pivot staleness</span><br><span class="line">        if len(results) == 0 &#123;</span><br><span class="line">            // If pivot sync is done, stop</span><br><span class="line">            if oldPivot == nil &#123;</span><br><span class="line">                return stateSync.Cancel()</span><br><span class="line">            &#125;</span><br><span class="line">            // If sync failed, stop</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-d.cancelCh:</span><br><span class="line">                return stateSync.Cancel()</span><br><span class="line">            default:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if d.chainInsertHook != nil &#123;</span><br><span class="line">            d.chainInsertHook(results)</span><br><span class="line">        &#125;</span><br><span class="line">        if oldPivot != nil &#123;</span><br><span class="line">            results = append(append([]*fetchResult&#123;oldPivot&#125;, oldTail...), results...)</span><br><span class="line">        &#125;</span><br><span class="line">        // Split around the pivot block and process the two sides via fast/full sync</span><br><span class="line">        if atomic.LoadInt32(&amp;d.committed) == 0 &#123;</span><br><span class="line">            latest = results[len(results)-1].Header</span><br><span class="line">            if height := latest.Number.Uint64(); height &gt; pivot+2*uint64(fsMinFullBlocks) &#123;</span><br><span class="line">                log.Warn(&quot;Pivot became stale, moving&quot;, &quot;old&quot;, pivot, &quot;new&quot;, height-uint64(fsMinFullBlocks))</span><br><span class="line">                pivot = height - uint64(fsMinFullBlocks)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        P, beforeP, afterP := splitAroundPivot(pivot, results)</span><br><span class="line">        if err := d.commitFastSyncData(beforeP, stateSync); err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">        if P != nil &#123;</span><br><span class="line">            // If new pivot block found, cancel old state retrieval and restart</span><br><span class="line">            if oldPivot != P &#123;</span><br><span class="line">                stateSync.Cancel()</span><br><span class="line"></span><br><span class="line">                stateSync = d.syncState(P.Header.Root)</span><br><span class="line">                defer stateSync.Cancel()</span><br><span class="line">                go func() &#123;</span><br><span class="line">                    if err := stateSync.Wait(); err != nil &amp;&amp; err != errCancelStateFetch &#123;</span><br><span class="line">                        d.queue.Close() // wake up WaitResults</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;()</span><br><span class="line">                oldPivot = P</span><br><span class="line">            &#125;</span><br><span class="line">            // Wait for completion, occasionally checking for pivot staleness</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-stateSync.done:</span><br><span class="line">                if stateSync.err != nil &#123;</span><br><span class="line">                    return stateSync.err</span><br><span class="line">                &#125;</span><br><span class="line">                if err := d.commitPivotBlock(P); err != nil &#123;</span><br><span class="line">                    return err</span><br><span class="line">                &#125;</span><br><span class="line">                oldPivot = nil</span><br><span class="line"></span><br><span class="line">            case &lt;-time.After(time.Second):</span><br><span class="line">                oldTail = afterP</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Fast sync done, pivot commit done, full import</span><br><span class="line">        if err := d.importBlockResults(afterP); err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1，同步最新的状态信息，的到最新的pivot值<br>2，不停的从d.queue 的result缓存中获取要处理的result数据<br>3，如果results数据为空，同时pivot也为空的时候，说明同步完成了，并返回<br>4，根据pivot值和results计算：pivot值对应的result，和pivot值之前的results和pivot值之后的results<br>5，调用commitFastSyncData把pivot值之前的results 插入本地区块链中，带上收据和交易数据<br>6，更新同步状态信息后，把pivot值对应的result 调用commitPivotBlock插入本地区块链中，并调用FastSyncCommitHead，记录这个pivot的hash值<br>7，调用d.importBlockResults把pivot值之后的results插入本地区块链中，这时候不插入区块交易收据数据。</p>
<p>3，processFullSyncContent()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">func (d *Downloader) processFullSyncContent() error &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        results := d.queue.Results(true)</span><br><span class="line">        if len(results) == 0 &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        if d.chainInsertHook != nil &#123;</span><br><span class="line">            d.chainInsertHook(results)</span><br><span class="line">        &#125;</span><br><span class="line">        if err := d.importBlockResults(results); err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Downloader) importBlockResults(results []*fetchResult) error &#123;</span><br><span class="line">    // Check for any early termination requests</span><br><span class="line">    if len(results) == 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-d.quitCh:</span><br><span class="line">        return errCancelContentProcessing</span><br><span class="line">    default:</span><br><span class="line">    &#125;</span><br><span class="line">    // Retrieve the a batch of results to import</span><br><span class="line">    first, last := results[0].Header, results[len(results)-1].Header</span><br><span class="line">    log.Debug(&quot;Inserting downloaded chain&quot;, &quot;items&quot;, len(results),</span><br><span class="line">        &quot;firstnum&quot;, first.Number, &quot;firsthash&quot;, first.Hash(),</span><br><span class="line">        &quot;lastnum&quot;, last.Number, &quot;lasthash&quot;, last.Hash(),</span><br><span class="line">    )</span><br><span class="line">    blocks := make([]*types.Block, len(results))</span><br><span class="line">    for i, result := range results &#123;</span><br><span class="line">        blocks[i] = types.NewBlockWithHeader(result.Header).WithBody(result.Transactions, result.Uncles)</span><br><span class="line">    &#125;</span><br><span class="line">    if index, err := d.blockchain.InsertChain(blocks); err != nil &#123;</span><br><span class="line">        log.Debug(&quot;Downloaded item processing failed&quot;, &quot;number&quot;, results[index].Header.Number, &quot;hash&quot;, results[index].Header.Hash(), &quot;err&quot;, err)</span><br><span class="line">        return errInvalidChain</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processFullSyncContent方法比较简单：直接获取缓存的results数据，并插入到本地区块链中。</p>
<p>总结：<br>Downloader看似非常复杂，其实逻辑还好，如果没有light模式，读起来会好很多。其实light模式不太成熟，基本也没什么用。fast模式比full模式逻辑上面多了一个pivot，处理起来就复杂很多。但是fast模式在本地存储了收据数据，大大减少了区块交易验证的时间。如果要更清楚明白fast模式的原理，可以看看以太坊白皮书关于fast模式同步这一部分：<a href="https://github.com/ethereum/go-ethereum/pull/1889">文档</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/categories/">Categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplyTransaction"><span class="toc-number">1.</span> <span class="toc-text">ApplyTransaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#handleMsg"><span class="toc-number">2.</span> <span class="toc-text">handleMsg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Start"><span class="toc-number">3.</span> <span class="toc-text">Start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fetch"><span class="toc-number">4.</span> <span class="toc-text">fetch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Downloader"><span class="toc-number">5.</span> <span class="toc-text">Downloader</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&text=eth_code_tx_event"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&title=eth_code_tx_event"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&is_video=false&description=eth_code_tx_event"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=eth_code_tx_event&body=Check out this article: https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&title=eth_code_tx_event"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&title=eth_code_tx_event"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&title=eth_code_tx_event"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&title=eth_code_tx_event"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/xiaoxuez/2019/10/14/eth-code-tx-event/&name=eth_code_tx_event&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 zoie
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/categories/">Categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
